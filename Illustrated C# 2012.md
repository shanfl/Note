第1章 C#和.NET框架 
1.1 在.NET之前 
1.1.1 20世纪90年代末的Windows编程 
1.1.2 下一代平台服务的目标 
1.2 .NET时代 
1.2.1 .NET框架的组成 
1.2.2 大大改进的编程环境 
1.3 编译成CIL 
1.4 编译成本机代码并执行 
1.5 CLR 
1.6 CLI 
1.7 各种缩写 
1.8 C#的演化 

第2章 C#编程概述 
2.1 一个简单的C#程序 
2.2 标识符 
2.3 关键字 
2.4 Main：程序的起始点 
2.5 空白 
2.6 语句 
2.7 从程序中输出文本 
2.7.1 Write 
2.7.2 WriteLine 
2.7.3 格式字符串 
2.7.4 多重标记和值 
2.7.5 格式化数字字符串 
2.8 注释：为代码添加注解 
2.8.1 关于注释的补充 
2.8.2 文档注释 
2.8.3 注释类型总结 

第3章 类型、存储和变量 
3.1 C#程序是一组类型声明 
3.2 类型是一种模板 
3.3 实例化类型 
3.4 数据成员和函数成员 
3.5 预定义类型 
3.6 用户定义类型 
3.7 栈和堆 
3.7.1 栈 
3.7.2 堆 
3.8 值类型和引用类型 
3.8.1 存储引用类型对象的成员 
3.8.2 C#类型的分类 
3.9 变量 
3.9.1 变量声明 
3.9.2 多变量声明 
3.9.3 使用变量的值 
3.10 静态类型和dynamic关键字 
3.11 可空类型 

第4章 类的基本概念 
4.1 类的概述 
4.2 程序和类：一个快速示例 
4.3 声明类 
4.4 类成员 
4.4.1 字段 
4.4.2 方法 
4.5 创建变量和类的实例 
4.6 为数据分配内存 
4.7 实例成员 
4.8 访问修饰符 
4.9 从类的内部访问成员 
4.10 从类的外部访问成员 
4.11 综合应用 

第5章 方法 
5.1 方法的结构 
5.2 方法体内部的代码执行 
5.3 本地变量 
5.3.1 类型推断和var关键字 
5.3.2 嵌套块中的本地变量 
5.4 本地常量 
5.5 控制流 
5.6 方法调用 
5.7 返回值 
5.8 返回语句和void方法 
5.9 参数 
5.9.1 形参 
5.9.2 实参 
5.10 值参数 
5.11 引用参数 
5.12 引用类型作为值参数和引用参数 
5.13 输出参数 
5.14 参数数组 
5.14.1 方法调用 
5.14.2 用数组作为实参 
5.15 参数类型总结 
5.16 方法重载 
5.17 命名参数 
5.18 可选参数 
5.19 栈帧 
5.20 递归 

第6章 深入理解类 
6.1 类成员 
6.2 成员修饰符的顺序 
6.3 实例类成员 
6.4 静态字段 
6.5 从类的外部访问静态成员 
6.5.1 静态字段示例 
6.5.2 静态成员的生存期 
6.6 静态函数成员 
6.7 其他静态类成员类型 
6.8 成员常量 
6.9 常量与静态量 
6.10 属性 
6.10.1 属性声明和访问器 
6.10.2 属性示例 
6.10.3 使用属性 
6.10.4 属性和关联字段 
6.10.5 执行其他计算 
6.10.6 只读和只写属性 
6.10.7 属性与公共字段 
6.10.8 计算只读属性示例 
6.10.9 自动实现属性 
6.10.10 静态属性 
6.11 实例构造函数 
6.11.1 带参数的构造函数 
6.11.2 默认构造函数 
6.12 静态构造函数 
6.13 对象初始化语句 
6.14 析构函数 
6.15 readonly修饰符 
6.16 this关键字 
6.17 索引器 
6.17.1 什么是索引器 
6.17.2 索引器和属性 
6.17.3 声明索引器 
6.17.4 索引器的set访问器 
6.17.5 索引器的get访问器 
6.17.6 关于索引器的补充 
6.17.7 为Employee示例声明索引器 
6.17.8 另一个索引器的示例 
6.17.9 索引器重载 
6.18 访问器的访问修饰符 
6.19 分部类和分部类型 
6.20 分部方法 

第7章 类和继承 
7.1 类继承 
7.2 访问继承的成员 
7.3 所有类都派生自object类 
7.4 屏蔽基类的成员 
7.5 基类访问 
7.6 使用基类的引用 
7.6.1 虚方法和覆写方法 
7.6.2 覆写标记为override的方法 
7.6.3 覆盖其他成员类型 
7.7 构造函数的执行 
7.7.1 构造函数初始化语句 
7.7.2 类访问修饰符 
7.8 程序集间的继承 
7.9 成员访问修饰符 
7.9.1 访问成员的区域 
7.9.2 公有成员的可访问性 
7.9.3 私有成员的可访问性 
7.9.4 受保护成员的可访问性 
7.9.5 内部成员的可访问性 
7.9.6 受保护内部成员的可访问性 
7.9.7 成员访问修饰符小结 
7.10 抽象成员 
7.11 抽象类 
7.11.1 抽象类和抽象方法的示例 
7.11.2 抽象类的另一个例子 
7.12 密封类 
7.13 静态类 
7.14 扩展方法 
7.15 命名约定 

第8章 表达式和运算符 
8.1 表达式 
8.2 字面量 
8.2.1 整数字面量 
8.2.2 实数字面量 
8.2.3 字符字面量 
8.2.4 字符串字面量 
8.3 求值顺序 
8.3.1 优先级 
8.3.2 结合性 
8.4 简单算术运算符 
8.5 求余运算符 
8.6 关系比较运算符和相等比较运算符 
8.7 递增运算符和递减运算符 
8.8 条件逻辑运算符 
8.9 逻辑运算符 
8.10 移位运算符 
8.11 赋值运算符 
8.12 条件运算符 
8.13 一元算术运算符 
8.14 用户定义的类型转换 
8.15 运算符重载 
8.15.1 运算符重载的限制 
8.15.2 运算符重载的示例 
8.16 typeof运算符 
8.17 其他运算符 

第9章 语句 
9.1 什么是语句 
9.2 表达式语句 
9.3 控制流语句 
9.4 if语句 
9.5 if...else语句 
9.6 while循环 
9.7 do循环 
9.8 for循环 
9.8.1 for语句中变量的作用域 
9.8.2 初始化和迭代表达式中的多表达式 
9.9 switch语句 
9.9.1 分支示例 
9.9.2 switch语句的补充 
9.9.3 分支标签 
9.10 跳转语句 
9.11 break语句 
9.12 continue语句 
9.13 标签语句 
9.13.1 标签 
9.13.2 标签语句的作用域 
9.14 goto语句 
9.15 using语句 
9.15.1 资源的包装使用 
9.15.2 using语句的示例 
9.15.3 多个资源和嵌套 
9.15.4 using语句的另一种形式 
9.16 其他语句 

第10章 结构 
10.1 什么是结构 
10.2 结构是值类型 
10.3 对结构赋值 
10.4 构造函数和析构函数 
10.4.1 实例构造函数 
10.4.2 静态构造函数 
10.4.3 构造函数和析构函数小结 
10.5 字段初始化语句是不允许的 
10.6 结构是密封的 
10.7 装箱和拆箱 
10.8 结构作为返回值和参数 
10.9 关于结构的其他信息 

第11章 枚举 
11.1 枚举 
11.1.1 设置底层类型和显式值 
11.1.2 隐式成员编号 
11.2 位标志 
11.2.1 Flags特性 
11.2.2 使用位标志的示例 
11.3 关于枚举的补充 

第12章 数组 
12.1 数组 
12.1.1 定义 
12.1.2 重要细节 
12.2 数组的类型 
12.3 数组是对象 
12.4 一维数组和矩形数组 
12.5 实例化一维数组或矩形数组 
12.6 访问数组元素 
12.7 初始化数组 
12.7.1 显式初始化一维数组 
12.7.2 显式初始化矩形数组 
12.7.3 初始化矩形数组的语法点 
12.7.4 快捷语法 
12.7.5 隐式类型数组 
12.7.6 综合内容 
12.8 交错数组 
12.8.1 声明交错数组 
12.8.2 快捷实例化 
12.8.3 实例化交错数组 
12.8.4 交错数组中的子数组 
12.9 比较矩形数组和交错数组 
12.10 foreach语句 
12.10.1 迭代变量是只读的 
12.10.2 foreach语句和多维数组 
12.11 数组协变 
12.12 数组继承的有用成员 
12.13 比较数组类型 

第13章 委托 
13.1 什么是委托 
13.2 委托概述 
13.3 声明委托类型 
13.4 创建委托对象 
13.5 给委托赋值 
13.6 组合委托 
13.7 为委托添加方法 
13.8 从委托移除方法 
13.9 调用委托 
13.10 委托的示例 
13.11 调用带返回值的委托 
13.12 调用带引用参数的委托 
13.13 匿名方法 
13.13.1 使用匿名方法 
13.13.2 匿名方法的语法 
13.13.3 变量和参数的作用域 
13.14 Lambda表达式 

第14章 事件 
14.1 发布者和订阅者 
14.2 源代码组件概览 
14.3 声明事件 
14.4 订阅事件 
14.5 触发事件 
14.6 标准事件的用法 
14.6.1 通过扩展EventArgs来传递数据 
14.6.2 移除事件处理程序 
14.7 事件访问器 

第15章 接口 
15.1 什么是接口 
15.2 声明接口 
15.3 实现接口 
15.4 接口是引用类型 
15.5 接口和as运算符 
15.6 实现多个接口 
15.7 实现具有重复成员的接口 
15.8 多个接口的引用 
15.9 派生成员作为实现 
15.10 显式接口成员实现 
15.11 接口可以继承接口 
15.12 不同类实现一个接口的示例 

第16章 转换 
16.1 什么是转换 
16.2 隐式转换 
16.3 显式转换和强制转换 
16.4 转换的类型 
16.5 数字的转换 
16.5.1 隐式数字转换 
16.5.2 溢出检测上下文 
16.5.3 显式数字转换 
16.6 引用转换 
16.6.1 隐式引用转换 
16.6.2 显式引用转换 
16.6.3 有效显式引用转换 
16.7 装箱转换 
16.7.1 装箱是创建副本 
16.7.2 装箱转换 
16.8 拆箱转换 
16.9 用户自定义转换 
16.9.1 用户自定义转换的约束 
16.9.2 用户自定义转换的示例 
16.9.3 评估用户自定义转换 
16.9.4 多步用户自定义转换的示例 
16.10 is运算符 
16.11 as运算符 

第17章 泛型 
17.1 什么是泛型 
17.2 C#中的泛型 
17.3 泛型类 
17.4 声明泛型类 
17.5 创建构造类型 
17.6 创建变量和实例 
17.6.1 使用泛型的栈的示例 
17.6.2 比较泛型和非泛型栈 
17.7 类型参数的约束 
17.7.1 Where子句 
17.7.2 约束类型和次序 
17.8 泛型方法 
17.8.1 声明泛型方法 
17.8.2 调用泛型方法 
17.8.3 泛型方法的示例 
17.9 扩展方法和泛型类 
17.10 泛型结构 
17.11 泛型委托 
17.12 泛型接口 
17.12.1 使用泛型接口的示例 
17.12.2 泛型接口的实现必须唯一 
17.13 协变 
17.14 逆变 
17.14.1 接口的协变和逆变 
17.14.2 有关可变性的更多内容 

第18章 枚举器和迭代器 
18.1 枚举器和可枚举类型 
18.2 IEnumerator接口 
18.3 泛型枚举接口 
18.4 迭代器 
18.4.1 迭代器块 
18.4.2 使用迭代器来创建枚举器 
18.4.3 使用迭代器来创建可枚举类型 
18.5 常见迭代器模式 
18.6 产生多个可枚举类型 
18.7 将迭代器作为属性 
18.8 迭代器实质 

第19章 LINQ 
19.1 什么是LINQ 
19.2 LINQ提供程序 
19.3 方法语法和查询语法 
19.4 查询变量 
19.5 查询表达式的结构 
19.5.1 from子句 
19.5.2 join子句 
19.5.3 什么是联结 
19.5.4 查询主体中的from...let...where片段 
19.5.5 orderby子句 
19.5.6 select...group子句 
19.5.7 查询中的匿名类型 
19.5.8 group子句 
19.5.9 查询延续：into子句 
19.6 标准查询运算符 
19.6.1 标准查询运算符的签名 
19.6.2 查询表达式和标准查询运算符 
19.6.3 将委托作为参数 
19.6.4 LINQ预定义的委托类型 
19.6.5 使用委托参数的示例 
19.6.6 使用Lambda表达式参数的示例 
19.7 LINQ to XML 
19.7.1 标记语言 
19.7.2 XML基础 
19.7.3 XML类 
19.7.4 使用XML特性 
19.7.5 节点的其他类型 
19.7.6 使用LINQ to XML的LINQ查询 

第20章 异步编程 
20.1 什么是异步 
20.2 async/await特性的结构 
20.3 什么是异步方法 
20.3.1 异步方法的控制流 
20.3.2 await表达式 
20.3.3 取消一个异步操作 
20.3.4 异常处理和await表达式 
20.3.5 在调用方法中同步地等待任务 
20.3.6 在异步方法中异步地等待任务 
20.3.7 Task.Delay方法 
20.4 在GUI程序中执行异步操作 
20.5 使用异步Lambda表达式 
20.6 完整的GUI程序 
20.7 BackgroundWorker类 
20.8 并行循环 
20.9 其他异步编程模式 
20.10 BeginInvoke和EndInvoke 
20.10.1 等待-直到结束模式 
20.10.2 AsyncResult类 
20.10.3 轮询模式 
20.10.4 回调模式 
20.11 计时器 

第21章 命名空间和程序集 
21.1 引用其他程序集 
21.2 命名空间 
21.2.1 命名空间名称 
21.2.2 命名空间的补充 
21.2.3 命名空间跨文件伸展 
21.2.4 嵌套命名空间 
21.3 using指令 
21.3.1 using命名空间指令 
21.3.2 using别名指令 
21.4 程序集的结构 
21.5 程序集标识符 
21.6 强命名程序集 
21.7 程序集的私有方式部署 
21.8 共享程序集和GAC 
21.8.1 把程序集安装到GAC 
21.8.2 GAC内的并肩执行 
21.9 配置文件 
21.10 延迟签名 

第22章 异常 
22.1 什么是异常 
22.2 try语句 
22.3 异常类 
22.4 catch子句 
22.5 使用特定catch子句的示例 
22.6 catch子句段 
22.7 finally块 
22.8 为异常寻找处理程序 
22.9 更进一步搜索 
22.9.1 一般法则 
22.9.2 搜索调用栈的示例 
22.10 抛出异常 
22.11 不带异常对象的抛出 

第23章 预处理指令 
23.1 什么是预处理指令 
23.2 基本规则 
23.3 #define和#undef指令 
23.4 条件编译 
23.5 条件编译结构 
23.6 诊断指令 
23.7 行号指令 
23.8 区域指令 
23.9 #pragma warning指令 

第24章 反射和特性 
24.1 元数据和反射 
24.2 Type类 
24.3 获取Type对象 
24.4 什么是特性 
24.5 应用特性 
24.6 预定义的保留的特性 
24.6.1 Obsolete特性 
24.6.2 Conditional特性 
24.6.3 调用者信息特性 
24.6.4 DebuggerStepThrough特性 
24.6.5 其他预定义特性 
24.7 有关应用特性的更多内容 
24.7.1 多个特性 
24.7.2 其他类型的目标 
24.7.3 全局特性 
24.8 自定义特性 
24.8.1 声明自定义特性 
24.8.2 使用特性的构造函数 
24.8.3 指定构造函数 
24.8.4 使用构造函数 
24.8.5 构造函数中的位置参数和命名参数 
24.8.6 限制特性的使用 
24.8.7 自定义特性的最佳实践 
24.9 访问特性 
24.9.1 使用IsDefined方法 
24.9.2 使用GetCustomAttributes方法 

第25章 其他主题 
25.1 概述 
25.2 字符串 
25.3 使用StringBuilder类 
25.4 把字符串解析为数据值 
25.5 关于可空类型的更多内容 
25.5.1 为可空类型赋值 
25.5.2 使用空接合运算符 
25.5.3 使用可空用户自定义类型 
25.6 Main方法 
25.7 文档注释 
25.7.1 插入文档注释 
25.7.2 使用其他XML标签 
25.8 嵌套类型 
25.8.1 嵌套类的示例 
25.8.2 可见性和嵌套类型 
25.9 析构函数和dispose模式 
25.9.1 标准dispose模式 
25.9.2 比较构造函数和析构函数 
25.10 和COM的互操作 
索引